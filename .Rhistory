n.trees = 500,
interaction.depth = 4
)
summary(boost_model)
# Align prediction length with training data
gb_forecast <- predict(boost_model, newdata = ts_chf_eu[1:length(y_train), ], n.trees = 500)
plot_train_pred(y_train, gb_forecast, "Gradient Boosting")
################################################################################
# Prophet ----
################################################################################
prophet_data <- data.frame(ds = ts_chf_eu$DATE, y = ts_chf_eu$Rate)
prophet_model <- prophet(prophet_data)
future <- make_future_dataframe(prophet_model, periods = 365)
forecast_prophet <- predict(prophet_model, future)
plot(prophet_model, forecast_prophet)
################################################################################
# Scenario Analysis ----
################################################################################
newdata <- data.frame(
Year = factor(rep("2025", 365), levels = levels(ts_chf_eu$Year)),
DayOfYear = seq(1, 365)
)
newdata$Rate <- predict(fit_lm, newdata = newdata)
# Alberto's code
# Is a mix of the the different scripts that we already wrote,
# it contains also some new models.
# To add:
# Diferent plots for the method
# Summaries and metrics evaluation and checks for the models and methods
# Clear environment
rm(list = ls())
# Load Packages ----
library(readxl)
library(ggplot2)
library(tidyverse)
library(dplyr)
library(forecast)
library(zoo)
library(DIMORA)
library(mgcv)
library(prophet)
library(gbm)
# Helper Functions ----
plot_train_pred <- function(y_train, y_pred, model_name) {
plot_data <- data.frame(
Time = 1:length(y_train),
Observed = y_train,
Predicted = y_pred
)
ggplot(plot_data, aes(x = Time)) +
geom_line(aes(y = Observed), color = "blue", linewidth = 1) +
geom_line(aes(y = Predicted), color = "red", linewidth = 1) +
labs(
title = paste("Observed vs Predicted Values\nModel:", model_name),
x = "Time",
y = "Values"
) +
theme_minimal()
}
# Load and Preprocess Data ----
swiss_eu <- read.csv2("Data/Swiss_Euro_daily_2020_2024.csv", sep = ",", na.strings = c("")) %>%
mutate(
DATE = as.Date(DATE, format = "%Y-%m-%d"),
Rate = as.numeric(Swiss.franc.Euro..EXR.D.CHF.EUR.SP00.A.)
) %>%
select(-Swiss.franc.Euro..EXR.D.CHF.EUR.SP00.A.)
# Check and handle missing values
swiss_eu$Rate <- zoo::na.locf(swiss_eu$Rate)
ts_chf_eu <- swiss_eu[swiss_eu$DATE >= as.Date("2020-01-01"), ] %>% mutate(
Year = as.factor(format(DATE, "%Y")),
DayOfYear = as.numeric(format(DATE, "%j"))
)
y <- ts(ts_chf_eu$Rate, frequency = 365, start = c(2020, 1))
y_diff <- diff(y)
# Visualizations ----
# Centered yearly time series
ggplot(ts_chf_eu %>% group_by(Year) %>% mutate(Rate = Rate - mean(Rate)) %>% ungroup(),
aes(x = DayOfYear, y = Rate, color = Year, group = Year)) +
geom_line() +
labs(x = "Days from Start of Year", y = "EUR/CHF (Centered)",
title = "Time Series for Each Year (Centered and Overlapped)") +
theme_minimal()
# Train-Test Split ----
n_sample <- floor(0.9 * length(y_diff))
y_train <- subset(y_diff, start = 1, end = n_sample)
y_test <- subset(y_diff, start = n_sample + 1)
# Models ----
## Classic Linear Model ----
ts_chf_eu$Year <- factor(ts_chf_eu$Year, levels = c(levels(ts_chf_eu$Year), "2025"))
fit_lm <- lm(Rate ~ DayOfYear + Year, data = ts_chf_eu)
summary(fit_lm)
# Predictions
lm_forecast <- predict(fit_lm, newdata = ts_chf_eu)
plot_train_pred(ts_chf_eu$Rate, lm_forecast, "Linear Model")
## Generalized Additive Model (GAM) ----
gam_model <- gam(Rate ~ s(DayOfYear, bs = "cs") + Year, data = ts_chf_eu)
summary(gam_model)
# Align prediction length with training data
gam_forecast <- predict(gam_model, newdata = ts_chf_eu[1:length(y_train), ])
plot_train_pred(y_train, gam_forecast, "GAM")
## ARIMA ----
fit_arima <- auto.arima(y_train)
summary(fit_arima)
forecast_arima <- forecast(fit_arima, h = length(y_test))
plot(forecast_arima, main = "ARIMA Forecast")
## Bass Model ----
fit_bm <- BM(y_train, display = TRUE)
summary(fit_bm)
## Gradient Boosting ----
boost_model <- gbm(
formula = Rate ~ Year + DayOfYear,
data = ts_chf_eu,
distribution = "gaussian",
n.trees = 500,
interaction.depth = 4
)
summary(boost_model)
# Align prediction length with training data
gb_forecast <- predict(boost_model, newdata = ts_chf_eu[1:length(y_train), ], n.trees = 500)
plot_train_pred(y_train, gb_forecast, "Gradient Boosting")
## Prophet ----
prophet_data <- data.frame(ds = ts_chf_eu$DATE, y = ts_chf_eu$Rate)
prophet_model <- prophet(prophet_data)
future <- make_future_dataframe(prophet_model, periods = 365)
forecast_prophet <- predict(prophet_model, future)
plot(prophet_model, forecast_prophet)
# Alberto's code
# Is a mix of the the different scripts that we already wrote,
# it contains also some new models.
# Clear environment
rm(list = ls())
# Load Necessary Packages ----
library(readxl)
library(ggplot2)
library(tidyverse)
library(dplyr)
library(forecast)
library(zoo)
library(DIMORA)
library(mgcv)
library(prophet)
library(gbm)
# Helper Functions ----
plot_train_pred <- function(y_train, y_pred, model_name) {
plot_data <- data.frame(
Time = 1:length(y_train),
Observed = y_train,
Predicted = y_pred
)
ggplot(plot_data, aes(x = Time)) +
geom_line(aes(y = Observed), color = "blue", linewidth = 1) +
geom_line(aes(y = Predicted), color = "red", linewidth = 1) +
labs(
title = paste("Observed vs Predicted Values\nModel:", model_name),
x = "Time",
y = "Values"
) +
theme_minimal()
}
calculate_metrics <- function(observed, predicted, model_name) {
rmse <- sqrt(mean((observed - predicted)^2, na.rm = TRUE))
mae <- mean(abs(observed - predicted), na.rm = TRUE)
mape <- mean(abs((observed - predicted) / observed), na.rm = TRUE) * 100
cat("\nModel:", model_name, "\n")
cat("RMSE:", rmse, "\n")
cat("MAE:", mae, "\n")
cat("MAPE:", mape, "%\n")
}
# Load and Preprocess Data ----
swiss_eu <- read.csv2("Data/Swiss_Euro_daily_2020_2024.csv", sep = ",", na.strings = c("")) %>%
mutate(
DATE = as.Date(DATE, format = "%Y-%m-%d"),
Rate = as.numeric(Swiss.franc.Euro..EXR.D.CHF.EUR.SP00.A.)
) %>%
select(-Swiss.franc.Euro..EXR.D.CHF.EUR.SP00.A.)
# Check and handle missing values
swiss_eu$Rate <- zoo::na.locf(swiss_eu$Rate)
ts_chf_eu <- swiss_eu[swiss_eu$DATE >= as.Date("2020-01-01"), ] %>% mutate(
Year = as.factor(format(DATE, "%Y")),
DayOfYear = as.numeric(format(DATE, "%j"))
)
y <- ts(ts_chf_eu$Rate, frequency = 365, start = c(2020, 1))
y_diff <- diff(y)
# Visualizations ----
# Centered yearly time series
ggplot(ts_chf_eu %>% group_by(Year) %>% mutate(Rate = Rate - mean(Rate)) %>% ungroup(),
aes(x = DayOfYear, y = Rate, color = Year, group = Year)) +
geom_line() +
labs(x = "Days from Start of Year", y = "EUR/CHF (Centered)",
title = "Time Series for Each Year (Centered and Overlapped)") +
theme_minimal()
# Train-Test Split ----
n_sample <- floor(0.9 * length(y_diff))
y_train <- subset(y_diff, start = 1, end = n_sample)
y_test <- subset(y_diff, start = n_sample + 1)
# Classic Linear Model ----
ts_chf_eu$Year <- factor(ts_chf_eu$Year, levels = c(levels(ts_chf_eu$Year), "2025"))
fit_lm <- lm(Rate ~ DayOfYear + Year, data = ts_chf_eu)
summary(fit_lm)
cat("Linear Model AIC:", AIC(fit_lm), "\n")
cat("Linear Model BIC:", BIC(fit_lm), "\n")
# Predictions
lm_forecast <- predict(fit_lm, newdata = ts_chf_eu)
plot_train_pred(ts_chf_eu$Rate, lm_forecast, "Linear Model")
calculate_metrics(ts_chf_eu$Rate, lm_forecast, "Linear Model")
# Generalized Additive Model (GAM) ----
gam_model <- gam(Rate ~ s(DayOfYear, bs = "cs") + Year, data = ts_chf_eu)
summary(gam_model)
cat("GAM AIC:", AIC(gam_model), "\n")
cat("GAM BIC:", BIC(gam_model), "\n")
# Align prediction length with training data
gam_forecast <- predict(gam_model, newdata = ts_chf_eu[1:length(y_train), ])
plot_train_pred(y_train, gam_forecast, "GAM")
calculate_metrics(y_train, gam_forecast, "GAM")
# ARIMA and Extensions ----
fit_arima <- auto.arima(y_train)
summary(fit_arima)
cat("ARIMA AIC:", fit_arima$aic, "\n")
cat("ARIMA BIC:", BIC(fit_arima), "\n")
forecast_arima <- forecast(fit_arima, h = length(y_test))
plot(forecast_arima, main = "ARIMA Forecast")
calculate_metrics(y_test, forecast_arima$mean, "ARIMA")
# Bass Model ----
fit_bm <- BM(y_train, display = TRUE)
summary(fit_bm)
# Gradient Boosting ----
boost_model <- gbm(
formula = Rate ~ Year + DayOfYear,
data = ts_chf_eu,
distribution = "gaussian",
n.trees = 500,
interaction.depth = 4
)
summary(boost_model)
# Align prediction length with training data
gb_forecast <- predict(boost_model, newdata = ts_chf_eu[1:length(y_train), ], n.trees = 500)
plot_train_pred(y_train, gb_forecast, "Gradient Boosting")
calculate_metrics(y_train, gb_forecast, "Gradient Boosting")
# Prophet ----
prophet_data <- data.frame(ds = ts_chf_eu$DATE, y = ts_chf_eu$Rate)
prophet_model <- prophet(prophet_data)
future <- make_future_dataframe(prophet_model, periods = 365)
forecast_prophet <- predict(prophet_model, future)
plot(prophet_model, forecast_prophet)
calculate_metrics(ts_chf_eu$Rate, forecast_prophet$yhat[1:length(ts_chf_eu$Rate)], "Prophet")
# Model Comparison ----
model_comparison <- data.frame(
Model = c("Linear Model", "GAM", "ARIMA", "Gradient Boosting", "Prophet"),
AIC = c(AIC(fit_lm), AIC(gam_model), fit_arima$aic, NA, NA),
BIC = c(BIC(fit_lm), BIC(gam_model), BIC(fit_arima), NA, NA)
)
print(model_comparison)
# Alberto's code
# Is a mix of the the different scripts that we already wrote,
# it contains also some new models.
# Clear environment
rm(list = ls())
# Load Necessary Packages ----
library(readxl)
library(ggplot2)
library(tidyverse)
library(dplyr)
library(forecast)
library(zoo)
library(DIMORA)
library(mgcv)
library(prophet)
library(gbm)
# Helper Functions ----
plot_train_pred <- function(y_train, y_pred, model_name) {
plot_data <- data.frame(
Time = 1:length(y_train),
Observed = y_train,
Predicted = y_pred
)
ggplot(plot_data, aes(x = Time)) +
geom_line(aes(y = Observed), color = "blue", linewidth = 1) +
geom_line(aes(y = Predicted), color = "red", linewidth = 1) +
labs(
title = paste("Observed vs Predicted Values\nModel:", model_name),
x = "Time",
y = "Values"
) +
theme_minimal()
}
calculate_metrics <- function(observed, predicted, model_name) {
rmse <- sqrt(mean((observed - predicted)^2, na.rm = TRUE))
mae <- mean(abs(observed - predicted), na.rm = TRUE)
mape <- mean(abs((observed - predicted) / observed), na.rm = TRUE) * 100
cat("\nModel:", model_name, "\n")
cat("RMSE:", rmse, "\n")
cat("MAE:", mae, "\n")
cat("MAPE:", mape, "%\n")
return(c(RMSE = rmse, MAE = mae, MAPE = mape))
}
# Load and Preprocess Data ----
swiss_eu <- read.csv2("Data/Swiss_Euro_daily_2020_2024.csv", sep = ",", na.strings = c("")) %>%
mutate(
DATE = as.Date(DATE, format = "%Y-%m-%d"),
Rate = as.numeric(Swiss.franc.Euro..EXR.D.CHF.EUR.SP00.A.)
) %>%
select(-Swiss.franc.Euro..EXR.D.CHF.EUR.SP00.A.)
# Check and handle missing values
swiss_eu$Rate <- zoo::na.locf(swiss_eu$Rate)
ts_chf_eu <- swiss_eu[swiss_eu$DATE >= as.Date("2020-01-01"), ] %>% mutate(
Year = as.factor(format(DATE, "%Y")),
DayOfYear = as.numeric(format(DATE, "%j"))
)
y <- ts(ts_chf_eu$Rate, frequency = 365, start = c(2020, 1))
y_diff <- diff(y)
# Visualizations ----
# Centered yearly time series
ggplot(ts_chf_eu %>% group_by(Year) %>% mutate(Rate = Rate - mean(Rate)) %>% ungroup(),
aes(x = DayOfYear, y = Rate, color = Year, group = Year)) +
geom_line() +
labs(x = "Days from Start of Year", y = "EUR/CHF (Centered)",
title = "Time Series for Each Year (Centered and Overlapped)") +
theme_minimal()
# Train-Test Split ----
n_sample <- floor(0.9 * length(y_diff))
y_train <- subset(y_diff, start = 1, end = n_sample)
y_test <- subset(y_diff, start = n_sample + 1)
# Classic Linear Model ----
ts_chf_eu$Year <- factor(ts_chf_eu$Year, levels = c(levels(ts_chf_eu$Year), "2025"))
fit_lm <- lm(Rate ~ DayOfYear + Year, data = ts_chf_eu)
summary(fit_lm)
cat("Linear Model AIC:", AIC(fit_lm), "\n")
cat("Linear Model BIC:", BIC(fit_lm), "\n")
# Predictions
lm_forecast <- predict(fit_lm, newdata = ts_chf_eu)
plot_train_pred(ts_chf_eu$Rate, lm_forecast, "Linear Model")
lm_metrics <- calculate_metrics(ts_chf_eu$Rate, lm_forecast, "Linear Model")
# Generalized Additive Model (GAM) ----
gam_model <- gam(Rate ~ s(DayOfYear, bs = "cs") + Year, data = ts_chf_eu)
summary(gam_model)
cat("GAM AIC:", AIC(gam_model), "\n")
cat("GAM BIC:", BIC(gam_model), "\n")
# Align prediction length with training data
gam_forecast <- predict(gam_model, newdata = ts_chf_eu[1:length(y_train), ])
plot_train_pred(y_train, gam_forecast, "GAM")
gam_metrics <- calculate_metrics(y_train, gam_forecast, "GAM")
# ARIMA and Extensions ----
fit_arima <- auto.arima(y_train)
summary(fit_arima)
cat("ARIMA AIC:", fit_arima$aic, "\n")
cat("ARIMA BIC:", BIC(fit_arima), "\n")
forecast_arima <- forecast(fit_arima, h = length(y_test))
plot(forecast_arima, main = "ARIMA Forecast")
arima_metrics <- calculate_metrics(y_test, forecast_arima$mean, "ARIMA")
# Bass Model ----
fit_bm <- BM(y_train, display = TRUE)
summary(fit_bm)
# Gradient Boosting ----
boost_model <- gbm(
formula = Rate ~ Year + DayOfYear,
data = ts_chf_eu,
distribution = "gaussian",
n.trees = 500,
interaction.depth = 4
)
summary(boost_model)
# Align prediction length with training data
gb_forecast <- predict(boost_model, newdata = ts_chf_eu[1:length(y_train), ], n.trees = 500)
plot_train_pred(y_train, gb_forecast, "Gradient Boosting")
gb_metrics <- calculate_metrics(y_train, gb_forecast, "Gradient Boosting")
# Prophet ----
prophet_data <- data.frame(ds = ts_chf_eu$DATE, y = ts_chf_eu$Rate)
prophet_model <- prophet(prophet_data)
future <- make_future_dataframe(prophet_model, periods = 365)
forecast_prophet <- predict(prophet_model, future)
plot(prophet_model, forecast_prophet)
prophet_metrics <- calculate_metrics(ts_chf_eu$Rate, forecast_prophet$yhat[1:length(ts_chf_eu$Rate)], "Prophet")
# Model Comparison ----
model_comparison <- data.frame(
Model = c("Linear Model", "GAM", "ARIMA", "Gradient Boosting", "Prophet"),
AIC = c(AIC(fit_lm), AIC(gam_model), fit_arima$aic, NA, NA),
BIC = c(BIC(fit_lm), BIC(gam_model), BIC(fit_arima), NA, NA),
RMSE = c(lm_metrics["RMSE"], gam_metrics["RMSE"], arima_metrics["RMSE"], gb_metrics["RMSE"], prophet_metrics["RMSE"]),
MAE = c(lm_metrics["MAE"], gam_metrics["MAE"], arima_metrics["MAE"], gb_metrics["MAE"], prophet_metrics["MAE"]),
MAPE = c(lm_metrics["MAPE"], gam_metrics["MAPE"], arima_metrics["MAPE"], gb_metrics["MAPE"], prophet_metrics["MAPE"])
)
print(model_comparison)
# Alberto's code
# Is a mix of the the different scripts that we already wrote,
# it contains also some new models.
# Clear environment
rm(list = ls())
# Load Necessary Packages ----
library(readxl)
library(ggplot2)
library(tidyverse)
library(dplyr)
library(forecast)
library(zoo)
library(DIMORA)
library(mgcv)
library(prophet)
library(gbm)
# Helper Functions ----
plot_train_pred <- function(y_train, y_pred, model_name) {
plot_data <- data.frame(
Time = 1:length(y_train),
Observed = y_train,
Predicted = y_pred
)
ggplot(plot_data, aes(x = Time)) +
geom_line(aes(y = Observed), color = "blue", linewidth = 1) +
geom_line(aes(y = Predicted), color = "red", linewidth = 1) +
labs(
title = paste("Observed vs Predicted Values\nModel:", model_name),
x = "Time",
y = "Values"
) +
theme_minimal()
}
calculate_metrics <- function(observed, predicted, model_name) {
rmse <- sqrt(mean((observed - predicted)^2, na.rm = TRUE))
mae <- mean(abs(observed - predicted), na.rm = TRUE)
mape <- mean(abs((observed - predicted) / observed), na.rm = TRUE) * 100
cat("\nModel:", model_name, "\n")
cat("RMSE:", rmse, "\n")
cat("MAE:", mae, "\n")
cat("MAPE:", mape, "%\n")
return(c(RMSE = rmse, MAE = mae, MAPE = mape))
}
# Load and Preprocess Data ----
swiss_eu <- read.csv2("Data/Swiss_Euro_daily_2020_2024.csv", sep = ",", na.strings = c("")) %>%
mutate(
DATE = as.Date(DATE, format = "%Y-%m-%d"),
Rate = as.numeric(Swiss.franc.Euro..EXR.D.CHF.EUR.SP00.A.)
) %>%
select(-Swiss.franc.Euro..EXR.D.CHF.EUR.SP00.A.)
# Check and handle missing values
swiss_eu$Rate <- zoo::na.locf(swiss_eu$Rate)
ts_chf_eu <- swiss_eu[swiss_eu$DATE >= as.Date("2020-01-01"), ] %>% mutate(
Year = as.factor(format(DATE, "%Y")),
DayOfYear = as.numeric(format(DATE, "%j"))
)
y <- ts(ts_chf_eu$Rate, frequency = 365, start = c(2020, 1))
y_diff <- diff(y)
# Visualizations ----
# Centered yearly time series
ggplot(ts_chf_eu %>% group_by(Year) %>% mutate(Rate = Rate - mean(Rate)) %>% ungroup(),
aes(x = DayOfYear, y = Rate, color = Year, group = Year)) +
geom_line() +
labs(x = "Days from Start of Year", y = "EUR/CHF (Centered)",
title = "Time Series for Each Year (Centered and Overlapped)") +
theme_minimal()
# Train-Test Split ----
n_sample <- floor(0.9 * length(y_diff))
y_train <- subset(y_diff, start = 1, end = n_sample)
y_test <- subset(y_diff, start = n_sample + 1)
# Classic Linear Model ----
ts_chf_eu$Year <- factor(ts_chf_eu$Year, levels = c(levels(ts_chf_eu$Year), "2025"))
fit_lm <- lm(Rate ~ DayOfYear + Year, data = ts_chf_eu)
summary(fit_lm)
cat("Linear Model AIC:", AIC(fit_lm), "\n")
cat("Linear Model BIC:", BIC(fit_lm), "\n")
# Predictions
lm_forecast <- predict(fit_lm, newdata = ts_chf_eu)
plot_train_pred(ts_chf_eu$Rate, lm_forecast, "Linear Model")
lm_metrics <- calculate_metrics(ts_chf_eu$Rate, lm_forecast, "Linear Model")
# Generalized Additive Model (GAM) ----
gam_model <- gam(Rate ~ s(DayOfYear, bs = "cs") + Year, data = ts_chf_eu)
summary(gam_model)
cat("GAM AIC:", AIC(gam_model), "\n")
cat("GAM BIC:", BIC(gam_model), "\n")
# Align prediction length with training data
gam_forecast <- predict(gam_model, newdata = ts_chf_eu[1:length(y_train), ])
plot_train_pred(y_train, gam_forecast, "GAM")
gam_metrics <- calculate_metrics(y_train, gam_forecast, "GAM")
# ARIMA and Extensions ----
fit_arima <- auto.arima(y_train)
summary(fit_arima)
cat("ARIMA AIC:", fit_arima$aic, "\n")
cat("ARIMA BIC:", BIC(fit_arima), "\n")
forecast_arima <- forecast(fit_arima, h = length(y_test))
plot(forecast_arima, main = "ARIMA Forecast")
arima_metrics <- calculate_metrics(y_test, forecast_arima$mean, "ARIMA")
# Bass Model ----
fit_bm <- BM(y_train, display = TRUE)
summary(fit_bm)
# Gradient Boosting ----
boost_model <- gbm(
formula = Rate ~ Year + DayOfYear,
data = ts_chf_eu,
distribution = "gaussian",
n.trees = 500,
interaction.depth = 4
)
summary(boost_model)
# Align prediction length with training data
gb_forecast <- predict(boost_model, newdata = ts_chf_eu[1:length(y_train), ], n.trees = 500)
plot_train_pred(y_train, gb_forecast, "Gradient Boosting")
gb_metrics <- calculate_metrics(y_train, gb_forecast, "Gradient Boosting")
# Prophet ----
prophet_data <- data.frame(ds = ts_chf_eu$DATE, y = ts_chf_eu$Rate)
prophet_model <- prophet(prophet_data)
future <- make_future_dataframe(prophet_model, periods = 365)
forecast_prophet <- predict(prophet_model, future)
plot(prophet_model, forecast_prophet)
prophet_metrics <- calculate_metrics(ts_chf_eu$Rate, forecast_prophet$yhat[1:length(ts_chf_eu$Rate)], "Prophet")
# Model Comparison ----
model_comparison <- data.frame(
Model = c("Linear Model", "GAM", "ARIMA", "Gradient Boosting", "Prophet"),
AIC = c(AIC(fit_lm), AIC(gam_model), fit_arima$aic, NA, NA),
BIC = c(BIC(fit_lm), BIC(gam_model), BIC(fit_arima), NA, NA),
RMSE = c(lm_metrics["RMSE"], gam_metrics["RMSE"], arima_metrics["RMSE"], gb_metrics["RMSE"], prophet_metrics["RMSE"]),
MAE = c(lm_metrics["MAE"], gam_metrics["MAE"], arima_metrics["MAE"], gb_metrics["MAE"], prophet_metrics["MAE"]),
MAPE = c(lm_metrics["MAPE"], gam_metrics["MAPE"], arima_metrics["MAPE"], gb_metrics["MAPE"], prophet_metrics["MAPE"])
)
print(model_comparison)
